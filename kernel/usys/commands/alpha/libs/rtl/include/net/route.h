
// File: route.h

#ifndef _NET_ROUTE_H_
#define _NET_ROUTE_H_


/*
 * A route consists of a destination address and a reference
 * to a routing entry.  These are often held by protocols
 * in their control blocks, e.g. inpcb.
 */
//struct route { };



/*
 * These numbers are used by reliable protocols for determining
 * retransmission behavior and are included in the routing structure.
 */
//struct rt_metrics { };


/*
 * rmx_rtt and rmx_rttvar are stored as microseconds;
 * RTTTOPRHZ(rtt) converts to a value suitable for use
 * by a protocol slowtimo counter.
 */
 // from netbsd
//#define	RTM_RTTUNIT	1000000	/* units for rtt, rttvar, as units per sec */
//#define	RTTTOPRHZ(r)	((r) / (RTM_RTTUNIT / PR_SLOWHZ))


/*
 * We distinguish between routes to hosts and routes to networks,
 * preferring the former if available.  For each route we infer
 * the interface to use from the gateway address supplied when
 * the route was entered.  Routes that forward packets through
 * gateways are marked so that the output routines know to address the
 * gateway rather than the ultimate destination.
 */
 
 
struct rtentry {

    int	rt_flags;		/* up/down?, host/net */
    int	rt_refcnt;		/* # held references */

    struct	sockaddr *rt_gateway;	/* value */

    /* FIXME: complete the struct */
    
};

/*
 * Following structure necessary for 4.3 compatibility;
 * We should eventually move it to a compat file.
 */
struct ortentry {
	
	uint32_t rt_hash;		/* to speed lookups */
	struct	sockaddr rt_dst;	/* key */
	struct	sockaddr rt_gateway;	/* value */
	int16_t	rt_flags;		/* up/down?, host/net */
	int16_t	rt_refcnt;		/* # held references */
	uint32_t rt_use;		/* raw # packets forwarded */
	
	// fixme: complete the structure.
	//struct	ifnet *rt_ifp;		/* the answer: interface to use */
};

#define	RTF_UP		0x1		/* route usable */
#define	RTF_GATEWAY	0x2		/* destination is a gateway */
#define	RTF_HOST	0x4		/* host entry (net otherwise) */
#define	RTF_REJECT	0x8		/* host or net unreachable */
#define	RTF_DYNAMIC	0x10		/* created dynamically (by redirect) */
#define	RTF_MODIFIED	0x20		/* modified dynamically (by redirect) */
#define RTF_DONE	0x40		/* message confirmed */
#define RTF_MASK	0x80		/* subnet mask present */
// #define RTF_CLONING	0x100		/* generate new routes on use */
#define RTF_CONNECTED	0x100		/* hosts on this route are neighbours */
// #define RTF_XRESOLVE	0x200		/* external daemon resolves name */
// #define RTF_LLINFO	0x400		/* generated by ARP or NDP */
#define RTF_LLDATA	0x400		/* used by apps to add/del L2 entries */
#define RTF_STATIC	0x800		/* manually added */
#define RTF_BLACKHOLE	0x1000		/* just discard pkts (during updates) */
// #define RTF_CLONED	0x2000		/* this is a cloned route */
#define RTF_PROTO2	0x4000		/* protocol specific routing flag */
#define RTF_PROTO1	0x8000		/* protocol specific routing flag */
#define RTF_SRC		0x10000		/* route has fixed source address */
#define RTF_ANNOUNCE	0x20000		/* announce new ARP or NDP entry */
#define RTF_LOCAL	0x40000		/* route represents a local address */
#define RTF_BROADCAST	0x80000		/* route represents a bcast address */
#define RTF_UPDATING	0x100000	/* route is updating */
/*
 * The flag is nevert set to rt_flags.  It just tells rtrequest1 to set a passed
 * ifa to rt_ifa (via rti_ifa) and not replace rt_ifa in ifa_rtrequest.
 */
#define RTF_DONTCHANGEIFA	0x200000	/* suppress rt_ifa replacement */


//#define RTF_UP 0x1      /* do not delete the route */
//#define RTF_GATEWAY 0x2 /* the route is a gateway and not an end host */


/*
 * Routing statistics.
 */
//struct	rtstat { };



#endif    



//
// End.
//



